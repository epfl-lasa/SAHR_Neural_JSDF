## Self collision avoidance
97% 1mm error



## regression for the distances between obj and hand
 - layers=[250, 130, 50], loss = [0, MSE, 2*MSE], Loss stops at 0.1026.


## only index and obj
- layers=[250, 130, 50], loss = [0.5MSE, MSE, 2*MSE]  loss= 0.08031698045141288 fixed, get stuck here. 0.91
- Net(35, 22, layer_nums=[400, 260, 100]), model_obj_03.pt   all dis 0.9775  min dis 0.674, 3mm error /
100 weight for  y_d<0 and y_a >0
- 5NNs, obj_22_dis_08_half,
w1 = 0.01 \
w2 = 10
w3 = 10
alpha = 1   model_obj_5NN_06, 
83.48%, 
layer_width=[250, 130, 50, 20]
- no overfitting. 



## Dataset collection
- Why not use Mujoco for data collection? Mujoco can return the collision information,
but we cannot get a continuous differential function as the distance, from which we can use as constraints
in optimization.

- The `penetration_depth` when collision happens is not computed in `FCL` for non-convex objects.
- Very important!!!We need to keep that the link frame has the same coordinates as the mesh file, which means
  that in `.urdf` file, the `<visual>` part of each mesh should be `<origin rpy="0 0 0" xyz="0 0 0 "/>`.
  `allegro_right_mount_meshes.urdf` is modified from `allegro_right_mount`.


## Flexible Collision Library [(FCL)](https://github.com/flexible-collision-library/fcl)
```angular2html
git clone https://github.com/danfis/libccd
cd src/
make CFLAGS='-fPIC' CXXFLAGES='-fPIC'
sudo make install
------------------------
git clone https://github.com/flexible-collision-library/fcl
mkdir build
cd build
cmake ..
make
cd test  &&   ./test_fcl_box_box # test if it works
# to use it with python, add the path of *.so
echo "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/xiao/research/lasa/open_source/simulation/fcl/build/lib" >> ~/.bashrc
```
install [python-fcl](https://github.com/neka-nat/python-fcl) by `pip install python-fcl`.\
try `example.py` and `test_pcl.py`.

```

/ccd/vec3.h:34:4: error: #error You must define CCD_SINGLE or CCD_DOUBLE
 #  error You must define CCD_SINGLE or CCD_DOUBLE
    ^
./ccd/vec3.h:88:5: error: unknown type name ‘ccd_real_t’
     ccd_real_t v[3];
...........
```
`
Adding #define CCD_DOUBLE to vec3.h may solve the problem.

`
## Problems
FCL could not return the correct penetration depth. Start to use `trimesh` library.

## Dataset
- `dataset10000000_15dis_sphere_2`,  10 million points,  [q, x, dis], [16, 3, 15]
- `obj_`, [q, x, dis], [16,3,5]

### hand obj collision
 - genrated by `allegro_right_dataset_trimesh.py` with convex meshes
 - `obj_single_convex_n_rate m.npy` means the n-th part with m times expansion of convex meshes. n=[0,1,2,3,4] means palm, index, middle, ring, thumb.
 - `obj_single_convex_n_combined.npy` refers to a combined dataset for all m=[1,2,5]. This is adopted for the training




 ## Final model
 ### hand obj collision
 - `NN_model/models/single_*01.pt`

 ### Self collision


# 2022 Nov. update

## SCA
- generate convex meshes `dataset/allegro_left_dataset.ipynb`
 - `allegro_right_left_SCAdataset_trimesh.py` generate dataset for right/left hand.
dataset shape: (1million, 16+10), 10 for the distances of pairs of 5 groups (palm, 4 fingers)
3 hours with 20 cores for 1 million samples,  collision rate is % # todo

## hand-object collision dataset
 - `allegro_right_left_dataset_trimesh.py` generate dataset for right/left hand.
 - `compare_FCL_NN_obj.py` validate models with 3 million datasets.


including 3 parts
1. rate_list = [1.1, 2, 5], enlarge the mesh with a cuboid by the rate. Then sample from the cuboid, with
transformation of forward kinematics.
2. dataset shape (n, 16+3+m), m = [2, 5, 5, 5, 5] for palm/index/middle/ring/thumb.
3. balance the dataset by `hand_obj_dataset_balance_left.ipynb`, also set the distance bound for each column for normalization, 
which needs to be put in `main_train_hand_obj_single.py`.
4. Only train 3 models for palm(including mount), index and thumb finer separately, since index/middle/ring fingers are the same.
However, the transformations between them should be generated and stored by kinematics,
which is generated by `motion_planning/visualize_NN_Rviz_single.ipynb`, different for left and right hand.
5. Validation by `visualize_NN_Rviz_multiple.py` in Rviz with `roslaunch urdf_tutorial display.launch model:=allegro_left_mount_meshes.urdf`
and `compare_FCL_NN_obj.py` for accuracy.

### *Notes*: 
1. remove the first two meshes of fingers when computing the distances between fingers and palm.
2. Trimesh could give the positive and negative (penetration) distances between two groups of meshes, which will
help a lot for the regression.
3. **Do not** run the code with Python Console. Otherwise raise  `_pickle.PicklingError:`



## Training:
`main_train_SCA2.py` for SCA 

## validation




 
